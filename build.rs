use std::{env, fs::File, io::Write, path::Path};

fn main() {
    dotenvy::dotenv().ok();

    // === build_info.rs codegen: ===
    // Get project name and version from environment variables set by Cargo
    let out_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not found");
    let pkg_name = env::var("CARGO_PKG_NAME").unwrap_or_else(|_| "unknown".to_string());
    let pkg_version = env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "unknown".to_string());

    // Use chrono to get the current UTC datetime (build time)
    let build_time = chrono::Utc::now();

    // Rust version
    let rust_version = rustc_version();

    // Read environment variable for dep versions, output by Cargo, via cargo metadata.
    // Use cargo_metadata to collect dependencies & versions
    let deps = get_lib_version_map().unwrap();

    let dest_path = Path::new(&out_dir).join("src/build_info.rs");
    let mut f = File::create(&dest_path).expect("Unable to create build_info.rs");

    // Write struct and impls at the top of build_info.rs
    let libs_count: usize = deps.list.len();

    let prelude = format!(
        r#"// autogenerated metadata - do not edit!
#[derive(Debug)]
pub struct LibVersion {{
    pub name: &'static str,
    pub version: &'static str,
}}

impl LibVersion {{
    pub fn get_name(&self) -> &'static str {{
        self.name
    }}
    pub fn get_version(&self) -> &'static str {{
        self.version
    }}
}}

pub struct LibVersionMap {{
    pub list: &'static [LibVersion],
}}

impl LibVersionMap {{
    pub fn get(&self, name: &str) -> Option<&LibVersion> {{
        self.list.iter().find(|v| v.get_name() == name)
    }}
}}

/// AUTO-GENERATED BY build.rs
pub const PROJECT_NAME: &str = {pkg_name:?};
pub const PROJECT_VERSION: &str = {pkg_version:?};
pub const BUILD_TIME_UTC: &str = "{}";
pub const RUSTC_VERSION: &str = {rust_version:?};
pub const LIB_VERSIONS: [LibVersion; {libs_count}] = ["#,
        build_time.to_rfc3339(),
        rust_version = rust_version,
        pkg_name = pkg_name,
        pkg_version = pkg_version,
        libs_count = libs_count
    );
    writeln!(f, "{prelude}").expect("Failed to write build_info.rs prelude");

    for dep in deps.list.iter() {
        writeln!(
            f,
            "    LibVersion {{ name: {:?}, version: {:?} }},",
            dep.name, dep.version
        )
        .expect("Failed to write dep entry");
    }
    writeln!(f, "];").expect("Failed to finish LIB_VERSIONS array");

    // Write a const LIB_VERSION_MAP as well
    writeln!(
        f,
        "pub const LIB_VERSION_MAP: LibVersionMap = LibVersionMap {{ list: &LIB_VERSIONS }};"
    )
    .expect("Failed to write LIB_VERSION_MAP const");
}

fn rustc_version() -> String {
    use std::process::Command;
    let output = Command::new("rustc").arg("--version").output();
    match output {
        Ok(output) if output.status.success() => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            stdout.trim().to_string()
        }
        _ => "unknown".to_string(),
    }
}

struct LibVersion {
    name: &'static str,
    version: &'static str,
}

#[allow(dead_code)]
impl LibVersion {
    fn get_name(&self) -> &'static str {
        self.name
    }
    fn get_version(&self) -> &'static str {
        self.version
    }
}

struct LibVersionMap {
    list: &'static [LibVersion],
}

#[allow(dead_code)]
impl LibVersionMap {
    fn get(&self, name: &str) -> Option<&LibVersion> {
        self.list.iter().find(|&v| v.get_name() == name)
    }
}

fn get_lib_version_map() -> Option<LibVersionMap> {
    use std::process::Command;
    // Remove --no-deps so we get all resolved dependency versions from Cargo.lock
    let output = Command::new("cargo")
        .args(["metadata", "--format-version", "1"])
        .output()
        .ok()?;
    if !output.status.success() {
        return None;
    }
    let metadata: serde_json::Value = serde_json::from_slice(&output.stdout).ok()?;
    let pkgs = metadata.get("packages")?.as_array()?;
    let resolve = metadata.get("resolve")?;
    let root_id = resolve.get("root")?.as_str()?;
    let root_pkg = pkgs
        .iter()
        .find(|pkg| pkg.get("id").and_then(|id| id.as_str()) == Some(root_id))?;

    // Get only dependencies specified in Cargo.toml (root package)
    let deps = root_pkg.get("dependencies")?.as_array()?;

    // Dependency names as a Vec for quick lookup
    let mut dep_names = Vec::new();
    for dep in deps {
        if let Some(dep_name) = dep.get("name").and_then(|n| n.as_str()) {
            dep_names.push(dep_name);
        }
    }

    // Now find all resolved packages (avoid root package itself), matching names from Cargo.toml
    let mut dep_vec = Vec::new();
    for pkg in pkgs {
        let pkg_name = pkg.get("name").and_then(|n| n.as_str())?;
        let pkg_id = pkg.get("id").and_then(|id| id.as_str())?;
        if pkg_id == root_id {
            continue; // skip root crate itself
        }
        if dep_names.contains(&pkg_name) {
            let version = pkg.get("version")?.as_str()?;
            dep_vec.push(LibVersion {
                name: Box::leak(pkg_name.to_owned().into_boxed_str()),
                version: Box::leak(version.to_owned().into_boxed_str()),
            });
        }
    }
    dep_vec.sort_by(|a, b| a.name.cmp(b.name));

    // leak dep_vec into static memory, yielding a &'static [LibVersion]
    let static_dep_slice: &'static [LibVersion] = {
        let boxed: Box<[LibVersion]> = dep_vec.into_boxed_slice();
        Box::leak(boxed)
    };

    Some(LibVersionMap {
        list: static_dep_slice,
    })
}
